<!DOCTYPE html>
<html lang="tr">
  <head>
    <meta charset="utf-8" />
    <title>ArcSys Harita</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- Leaflet -->
    <link rel="stylesheet" href="leaflet/leaflet.css" />
    <script src="leaflet/leaflet.js"></script>

    <style>
      html,
      body {
        height: 100%;
        margin: 0;
        padding: 0;
        background: #050505;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          sans-serif;
      }

      #map {
        width: 100%;
        height: 100%;
      }

      /* ---------------------------
         Filtre input'u (üst sol)
      ---------------------------- */
      #filter-container {
        position: absolute;
        top: 10px;
        left: 60px;
        z-index: 1000;
      }

      #filter-input {
        padding: 4px 9px;
        font-size: 11px;
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.16);
        background: rgba(20, 20, 20, 0.78);
        color: #f5f5f5;
        min-width: 230px;
        outline: none;
        box-shadow: 0 8px 22px rgba(0, 0, 0, 0.45);
        backdrop-filter: blur(14px);
        -webkit-backdrop-filter: blur(14px);
      }

      #filter-input::placeholder {
        color: rgba(230, 230, 230, 0.65);
      }

      #filter-input:focus {
        border-color: rgba(255, 255, 255, 0.32);
        box-shadow: 0 10px 26px rgba(0, 0, 0, 0.6);
      }

      /* ---------------------------
         Leaflet genel kontrol stili
      ---------------------------- */

      .leaflet-control {
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          sans-serif;
        font-size: 11px;
      }

      /* Zoom butonları */
      .leaflet-control-zoom.leaflet-bar {
        border-radius: 10px;
        overflow: hidden;
        background: rgba(15, 15, 15, 0.84);
        backdrop-filter: blur(14px);
        -webkit-backdrop-filter: blur(14px);
        border: 1px solid rgba(255, 255, 255, 0.08);
        box-shadow: 0 14px 32px rgba(0, 0, 0, 0.6);
      }

      .leaflet-bar a,
      .leaflet-bar a:hover {
        background: transparent;
        border: none;
        color: #f5f5f5;
      }

      .leaflet-bar a {
        width: 28px;
        height: 28px;
        line-height: 28px;
        font-size: 16px;
      }

      .leaflet-bar a:hover {
        background: rgba(255, 255, 255, 0.08);
      }

      /* ---------------------------
         Özel Layers Paneli (sağ üst)
      ---------------------------- */
      #layer-panel {
        position: absolute;
        top: 10px;
        right: 10px;
        z-index: 1100;
        max-width: 260px;
        color: #f5f5f5;
        background: rgba(15, 15, 15, 0.84);
        backdrop-filter: blur(14px);
        -webkit-backdrop-filter: blur(14px);
        border-radius: 14px;
        border: 1px solid rgba(255, 255, 255, 0.08);
        box-shadow: 0 14px 32px rgba(0, 0, 0, 0.6);
        font-size: 11px;
        overflow: hidden;
      }

      #layer-panel.collapsed #layer-panel-body {
        display: none;
      }

      #layer-panel-header {
        padding: 6px 8px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: space-between;
        font-weight: 600;
        letter-spacing: 0.02em;
        background: radial-gradient(
            circle at top left,
            rgba(214, 176, 107, 0.3),
            transparent 55%
          ),
          transparent;
      }

      #layer-panel-header span.title {
        font-size: 11px;
      }

      #layer-panel-header span.toggle-icon {
        font-size: 12px;
        opacity: 0.8;
      }

      #layer-panel-body {
        padding: 4px 6px 6px 6px;
        max-height: 260px;
        overflow-y: auto;
      }

      .layer-item {
        display: flex;
        align-items: center;
        gap: 4px;
        padding: 3px 4px;
        border-radius: 6px;
        margin-bottom: 2px;
        background: rgba(255, 255, 255, 0.02);
      }

      .layer-item.dragging {
        opacity: 0.6;
        background: rgba(214, 176, 107, 0.18);
      }

      .layer-checkbox {
        margin: 0;
      }

      .layer-label {
        flex: 1;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        cursor: pointer;
      }

      .layer-slider {
        width: 70px;
      }

      .layer-slider input[type="range"] {
        width: 100%;
      }

      .layer-handle {
        cursor: grab;
        font-size: 12px;
        opacity: 0.6;
        user-select: none;
      }

      .layer-item:hover {
        background: rgba(255, 255, 255, 0.06);
      }

      /* ---------------------------
         Lejant (alt sağ) - açılır/kapanır
      ---------------------------- */
      .info.legend {
        padding: 0;
        border-radius: 14px;
        background: transparent;
      }

      .legend-card {
        padding: 0;
        border-radius: 14px;
        background: rgba(15, 15, 15, 0.84);
        backdrop-filter: blur(14px);
        -webkit-backdrop-filter: blur(14px);
        border: 1px solid rgba(255, 255, 255, 0.08);
        box-shadow: 0 14px 32px rgba(0, 0, 0, 0.6);
        max-width: 220px;
      }

      .legend-header {
        padding: 6px 8px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        cursor: pointer;
        font-size: 11px;
        font-weight: 600;
        letter-spacing: 0.02em;
        background: radial-gradient(
            circle at top left,
            rgba(214, 176, 107, 0.3),
            transparent 55%
          ),
          transparent;
        color: #f9f4ea;
      }

      .legend-header .toggle-icon {
        font-size: 12px;
        opacity: 0.8;
      }

      .legend-body {
        padding: 4px 8px 6px 8px;
      }

      .legend-card.collapsed .legend-body {
        display: none;
      }

      .legend-row {
        display: flex;
        align-items: center;
        gap: 6px;
        margin-bottom: 3px;
        font-size: 11px;
        color: #f0e7d8;
      }

      .legend-swatch {
        width: 12px;
        height: 12px;
        border-radius: 3px;
      }

      .legend-swatch.round {
        border-radius: 50%;
      }

      .legend-scale-title {
        font-size: 10px;
        margin-top: 6px;
        margin-bottom: 2px;
        color: #e1d4bf;
      }

      .legend-scale-bar {
        width: 140px;
        height: 10px;
        border-radius: 5px;
        background: linear-gradient(
          to right,
          #0000ff,
          #00ffff,
          #ffff00,
          #ff0000
        );
        box-shadow: inset 0 0 4px rgba(0, 0, 0, 0.4);
      }

      .legend-z-text {
        margin-top: 4px;
        font-size: 10px;
        color: #d5c7ad;
      }
    </style>
  </head>
  <body>
    <div id="map"></div>

    <!-- Filtre -->
    <div id="filter-container">
      <input
        id="filter-input"
        placeholder="Filtre: buluntular / seviye (örn. Locus 1)"
      />
    </div>

    <!-- Özel Layers Panel -->
    <div id="layer-panel" class="collapsed">
      <div id="layer-panel-header">
        <span class="title">Katmanlar</span>
        <span class="toggle-icon">▸</span>
      </div>
      <div id="layer-panel-body">
        <div id="layer-list"></div>
      </div>
    </div>

    <script>
      const trenchesData = __TRENCHES_JSON__;
      const findsData = __FINDS_JSON__;
      const extraLayers = __LAYERS_JSON__;
      const errorMsg = "__ERROR_MSG__";
      const centerLat = __CENTER_LAT__;
      const centerLon = __CENTER_LON__;

      const trenchLayers = {};
      const findLayers = {};

      // Map
      const map = L.map("map").setView([centerLat, centerLon], 17);

      // Offline raster’lar için tek pane
      const rasterPane = map.createPane("rasterPane");
      rasterPane.style.zIndex = 350; // OSM'in üstünde

      const osmLayer = L.tileLayer(
        "https://tile.openstreetmap.org/{z}/{x}/{y}.png",
        {
          maxZoom: 22,
          attribution: "© OpenStreetMap contributors",
        }
      ).addTo(map);

      const overlayEntries = [];
      let firstImageBounds = null;

      // URL'den zoom aralığını oku (…_z12_15/{z}/{x}/{y}.png)
      function parseZoomRangeFromUrlTemplate(urlTemplate) {
        const re = /_z(\d+)_(\d+)\/\{z\}\/\{x\}\/\{y\}\.png$/;
        const m = urlTemplate.match(re);
        if (!m) return null;
        return {
          minZoom: parseInt(m[1], 10),
          maxZoom: parseInt(m[2], 10),
        };
      }

      // Tile & image layer'ları oluştur (hepsi rasterPane'de)
      extraLayers.forEach((l) => {
        if (l.kind === "tile" && l.url_template) {
          const zoomInfo = parseZoomRangeFromUrlTemplate(l.url_template);

          const opts = {
            attribution: l.attribution || "",
            noWrap: true,
            pane: "rasterPane",
          };

          if (zoomInfo) {
            opts.maxNativeZoom = zoomInfo.maxZoom;
          }

          const layer = L.tileLayer(l.url_template, opts).addTo(map);
          overlayEntries.push({
            name: l.name,
            layer,
            kind: "tile",
          });
        } else if (l.kind === "image" && l.file_url) {
          const bounds = [
            [l.min_lat, l.min_lon],
            [l.max_lat, l.max_lon],
          ];
          const layer = L.imageOverlay(l.file_url, bounds, {
            opacity: 0.8,
            pane: "rasterPane",
          }).addTo(map);
          overlayEntries.push({
            name: l.name,
            layer,
            kind: "image",
          });
          if (!firstImageBounds) firstImageBounds = bounds;
        }
      });

      if (firstImageBounds) {
        map.fitBounds(firstImageBounds, { padding: [20, 20] });
      }

      if (errorMsg && errorMsg.trim().length > 0) {
        L.popup()
          .setLatLng([centerLat, centerLon])
          .setContent("Harita verisi yüklenirken hata: " + errorMsg)
          .openOn(map);
      }

      // Z renk skalası
      let zMin = null;
      let zMax = null;
      findsData.forEach((f) => {
        if (f.z == null) return;
        if (zMin === null || f.z < zMin) zMin = f.z;
        if (zMax === null || f.z > zMax) zMax = f.z;
      });

      function getColorForZ(z) {
        if (z == null || zMin === null || zMax === null) {
          return "#888888";
        }
        let t = (z - zMin) / (zMax - zMin || 1);
        if (t < 0) t = 0;
        if (t > 1) t = 1;

        if (t < 0.33) {
          const k = t / 0.33;
          const g = Math.round(255 * k);
          const b = 255;
          return `rgb(0,${g},${b})`;
        } else if (t < 0.66) {
          const k = (t - 0.33) / 0.33;
          const r = Math.round(255 * k);
          const g = 255;
          const b = Math.round(255 * (1 - k));
          return `rgb(${r},${g},${b})`;
        } else {
          const k = (t - 0.66) / 0.34;
          const g = Math.round(255 * (1 - k));
          return `rgb(255,${g},0)`;
        }
      }

      // Açmalar
      trenchesData.forEach((t) => {
        if (!t.vertices || !t.vertices.length) return;

        const latlngs = t.vertices.map((v) => [v.lat, v.lon]);

        const poly = L.polygon(latlngs, {
          color: "#4c9be8",
          fillColor: "#4c9be8",
          weight: 2,
          fillOpacity: 0.15,
        }).addTo(map);

        const popupText =
          "<b>Açma: </b>" +
          t.code +
          (t.name ? " – " + t.name : "") +
          "<br>" +
          "<b>Proje: </b>" +
          (t.project || "") +
          "<br>" +
          "Köşe sayısı: " +
          t.vertices.length;

        poly.bindPopup(popupText);

        trenchLayers[t.id] = poly;
      });

      // Buluntular
      findsData.forEach((f) => {
        if (f.lat == null || f.lon == null) return;

        const color = getColorForZ(f.z);

        const marker = L.circleMarker([f.lat, f.lon], {
          radius: 5,
          weight: 1,
          color: color,
          fillColor: color,
          fillOpacity: 0.9,
        }).addTo(map);

        const popupText =
          "<b>Buluntu: </b>" +
          f.code +
          "<br>" +
          "<b>Açma: </b>" +
          (f.trench_code || f.trench_id) +
          (f.trench_name ? " – " + f.trench_name : "") +
          "<br>" +
          (f.level_name ? "<b>Seviye: </b>" + f.level_name + "<br>" : "") +
          (f.description ? "Açıklama: " + f.description + "<br>" : "") +
          (f.z != null ? "Z: " + f.z + " m" : "");

        marker.bindPopup(popupText);

        findLayers[f.id] = marker;
      });

      // ---------------------------
      //  Lejant (Leaflet control)
      // ---------------------------
      const legend = L.control({ position: "bottomright" });
      legend.onAdd = function () {
        const div = L.DomUtil.create("div", "info legend");
        div.innerHTML = `
          <div class="legend-card collapsed">
            <div class="legend-header">
              <span>Lejant</span>
              <span class="toggle-icon">▸</span>
            </div>
            <div class="legend-body">
              <div class="legend-row">
                <span class="legend-swatch" style="background:#4c9be8;"></span>
                <span>Açmalar</span>
              </div>
              <div class="legend-row">
                <span class="legend-swatch round" style="background:#d62728;"></span>
                <span>Buluntular (Z'ye göre renk)</span>
              </div>
              <div class="legend-scale-title">Z Skala</div>
              <div class="legend-scale-bar"></div>
              ${
                zMin !== null && zMax !== null
                  ? `<div class="legend-z-text">Z min: ${zMin.toFixed(
                      2
                    )} m<br>Z max: ${zMax.toFixed(2)} m</div>`
                  : ""
              }
            </div>
          </div>
        `;
        setTimeout(() => {
          const card = div.querySelector(".legend-card");
          const header = div.querySelector(".legend-header");
          const icon = div.querySelector(".toggle-icon");
          header.addEventListener("click", () => {
            const isCollapsed = card.classList.toggle("collapsed");
            if (icon) icon.textContent = isCollapsed ? "▸" : "▾";
          });
        }, 0);
        return div;
      };
      legend.addTo(map);

      // ---------------------------
      //  Özel Layers Panel (Drag + Opacity)
      // ---------------------------
      const layerPanel = document.getElementById("layer-panel");
      const layerPanelHeader = document.getElementById("layer-panel-header");
      const layerPanelBody = document.getElementById("layer-panel-body");
      const layerListEl = document.getElementById("layer-list");

      // panel aç/kapa
      layerPanelHeader.addEventListener("click", () => {
        const isCollapsed = layerPanel.classList.toggle("collapsed");
        const icon = layerPanelHeader.querySelector(".toggle-icon");
        if (icon) icon.textContent = isCollapsed ? "▸" : "▾";
      });

      let dragSrcEl = null;

      function buildLayerPanel() {
        layerListEl.innerHTML = "";

        overlayEntries.forEach((entry) => {
          const item = document.createElement("div");
          item.className = "layer-item";
          item.dataset.layerName = entry.name;

          const checkbox = document.createElement("input");
          checkbox.type = "checkbox";
          checkbox.className = "layer-checkbox";
          checkbox.checked = true;

          const label = document.createElement("div");
          label.className = "layer-label";
          label.textContent = entry.name;

          const sliderWrap = document.createElement("div");
          sliderWrap.className = "layer-slider";
          const slider = document.createElement("input");
          slider.type = "range";
          slider.min = "0";
          slider.max = "100";
          slider.value = "100";
          slider.title = "Opacity";
          sliderWrap.appendChild(slider);

          const handle = document.createElement("div");
          handle.className = "layer-handle";
          handle.textContent = "⋮⋮";
          handle.draggable = true;

          item.appendChild(checkbox);
          item.appendChild(label);
          item.appendChild(sliderWrap);
          item.appendChild(handle);

          // görünürlük
          checkbox.addEventListener("change", () => {
            if (checkbox.checked) {
              entry.layer.addTo(map);
              updateLayerOrderFromDom();
            } else {
              map.removeLayer(entry.layer);
            }
          });

          // opacity
          slider.addEventListener("input", () => {
            const val = parseInt(slider.value, 10) / 100;
            if (entry.layer.setOpacity) {
              entry.layer.setOpacity(val);
            } else if (entry.layer._image) {
              entry.layer._image.style.opacity = val;
            }
          });

          ["mousedown", "touchstart", "click"].forEach((evt) => {
            slider.addEventListener(
              evt,
              (e) => {
                e.stopPropagation();
              },
              { passive: true }
            );
          });

          label.addEventListener("click", () => {
            checkbox.checked = !checkbox.checked;
            checkbox.dispatchEvent(new Event("change"));
          });

          // DRAG & DROP – sadece handle'dan
          handle.addEventListener("dragstart", (e) => {
            dragSrcEl = item;
            item.classList.add("dragging");
            e.dataTransfer.effectAllowed = "move";
          });

          handle.addEventListener("dragend", () => {
            if (dragSrcEl) {
              dragSrcEl.classList.remove("dragging");
            }
            dragSrcEl = null;
            updateLayerOrderFromDom();
          });

          item.addEventListener("dragover", (e) => {
            e.preventDefault();
            if (!dragSrcEl || dragSrcEl === item) return;
            const rect = item.getBoundingClientRect();
            const midY = rect.top + rect.height / 2;
            const parent = item.parentNode;
            if (e.clientY < midY) {
              parent.insertBefore(dragSrcEl, item);
            } else {
              parent.insertBefore(dragSrcEl, item.nextSibling);
            }
          });

          item.addEventListener("drop", (e) => {
            e.preventDefault();
            updateLayerOrderFromDom();
          });

          layerListEl.appendChild(item);
        });
      }

      function updateLayerOrderFromDom() {
        const items = Array.from(layerListEl.querySelectorAll(".layer-item"));
        const total = items.length;

        // En ÜSTTE görünen item en YÜKSEK zIndex'e sahip olsun
        items.forEach((item, index) => {
          const name = item.dataset.layerName;
          const entry = overlayEntries.find((e) => e.name === name);
          if (!entry || !map.hasLayer(entry.layer)) return;

          const z = 100 + (total - 1 - index); // index 0 → en büyük zIndex
          if (typeof entry.layer.setZIndex === "function") {
            entry.layer.setZIndex(z);
          } else if (entry.layer._image) {
            entry.layer._image.style.zIndex = z;
          }
        });
      }

      buildLayerPanel();
      updateLayerOrderFromDom();

      // ---------------------------
      //  Filtreleme
      // ---------------------------
      function applyFilter(rawQuery) {
        const q = (rawQuery || "").trim().toLowerCase();

        Object.values(trenchLayers).forEach((l) => map.removeLayer(l));
        Object.values(findLayers).forEach((l) => map.removeLayer(l));

        if (!q) {
          Object.values(trenchLayers).forEach((l) => l.addTo(map));
          Object.values(findLayers).forEach((l) => l.addTo(map));
          return;
        }

        if (q.includes("buluntu")) {
          Object.values(findLayers).forEach((l) => l.addTo(map));
          return;
        }

        if (q.includes("açma")) {
          Object.values(trenchLayers).forEach((l) => l.addTo(map));
          return;
        }

        const tokens = q.split(/\s+/).filter(Boolean);

        const visibleFindIds = [];
        const visibleTrenchIds = new Set();

        findsData.forEach((f) => {
          let text = "";
          if (f.code) text += " " + f.code;
          if (f.description) text += " " + f.description;
          if (f.trench_code) text += " " + f.trench_code;
          if (f.trench_name) text += " " + f.trench_name;
          if (f.level_name) text += " " + f.level_name;

          const t = text.toLowerCase();
          const allMatch = tokens.every((tok) => t.includes(tok));
          if (allMatch) {
            visibleFindIds.push(f.id);
            visibleTrenchIds.add(f.trench_id);
          }
        });

        trenchesData.forEach((t) => {
          let text = "";
          if (t.code) text += " " + t.code;
          if (t.name) text += " " + t.name;
          if (t.project) text += " " + t.project;

          const tt = text.toLowerCase();
          const allMatch = tokens.every((tok) => tt.includes(tok));
          if (allMatch) {
            visibleTrenchIds.add(t.id);
          }
        });

        if (!visibleFindIds.length && !visibleTrenchIds.size) {
          Object.values(findLayers).forEach((l) => l.addTo(map));
          return;
        }

        visibleFindIds.forEach((id) => {
          const layer = findLayers[id];
          if (layer) layer.addTo(map);
        });

        visibleTrenchIds.forEach((tid) => {
          const layer = trenchLayers[tid];
          if (layer) layer.addTo(map);
        });
      }

      const filterInput = document.getElementById("filter-input");
      if (filterInput) {
        filterInput.addEventListener("keyup", (e) => {
          if (e.key === "Enter") {
            applyFilter(filterInput.value);
          }
        });
        filterInput.addEventListener("change", () => {
          applyFilter(filterInput.value);
        });
      }

      // Odak fonksiyonları (Qt'den)
      function focusOnTrench(trenchId) {
        const layer = trenchLayers[trenchId];
        if (layer) {
          map.fitBounds(layer.getBounds(), { padding: [30, 30] });
          layer.openPopup();
        }
      }

      function focusOnFind(findId) {
        const layer = findLayers[findId];
        if (layer) {
          map.setView(layer.getLatLng(), 19);
          layer.openPopup();
        }
      }

      function focusOnAllTrenches() {
        const ids = Object.keys(trenchLayers);
        if (!ids.length) return;
        let bounds = null;
        ids.forEach((id) => {
          const b = trenchLayers[id].getBounds();
          bounds = bounds ? bounds.extend(b) : b;
        });
        if (bounds) {
          map.fitBounds(bounds, { padding: [30, 30] });
        }
      }

      function focusOnAllFinds() {
        const ids = Object.keys(findLayers);
        if (!ids.length) return;
        const latlngs = ids.map((id) => findLayers[id].getLatLng());
        let bounds = null;
        latlngs.forEach((ll) => {
          bounds = bounds ? bounds.extend(ll) : L.latLngBounds(ll, ll);
        });
        if (bounds) {
          map.fitBounds(bounds, { padding: [30, 30] });
        }
      }

      window.focusOnTrench = focusOnTrench;
      window.focusOnFind = focusOnFind;
      window.focusOnAllTrenches = focusOnAllTrenches;
      window.focusOnAllFinds = focusOnAllFinds;
      window.applyFilter = applyFilter;
    </script>
  </body>
</html>
