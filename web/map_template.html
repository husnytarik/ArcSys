<!DOCTYPE html>
<html lang="tr">
  <head>
    <meta charset="utf-8" />
    <title>ArcSys Harita</title>

    <link rel="stylesheet" href="leaflet/leaflet.css" />
    <script src="leaflet/leaflet.js"></script>
    <link rel="stylesheet" href="map_style.css" />
    <script>
      // Python bu değişkeni dolduruyor:
      const THEME_CSS_VARS = `__THEME_CSS_VARS__`;

      // CSS değişkenlerini DOM'a bas
      const root = document.documentElement;

      THEME_CSS_VARS.split("\n").forEach((line) => {
        const trimmed = line.trim();
        if (!trimmed) return;
        const [key, value] = trimmed.replace(";", "").split(":");
        if (key && value) {
          root.style.setProperty(key.trim(), value.trim());
        }
      });
    </script>
  </head>

  <body>
    <div id="map"></div>

    <!-- Filtre -->
    <div id="filter-container">
      <input
        id="filter-input"
        placeholder="Filtre: buluntular / seviye (örn. Locus 1)"
      />
    </div>

    <!-- Özel Layers Panel -->
    <div id="layer-panel" class="collapsed">
      <div id="layer-panel-header">
        <span class="title">Katmanlar</span>
        <span class="toggle-icon">▸</span>
      </div>
      <div id="layer-panel-body">
        <div id="layer-list"></div>
      </div>
    </div>

    <script>
      const trenchesData = __TRENCHES_JSON__;
      const findsData = __FINDS_JSON__;
      const extraLayers = __LAYERS_JSON__;
      const errorMsg = "__ERROR_MSG__";
      const centerLat = __CENTER_LAT__;
      const centerLon = __CENTER_LON__;

      const trenchLayers = {};
      const findLayers = {};

      // Map
      const map = L.map("map").setView([centerLat, centerLon], 17);

      // Qt'den gelen layer visibility bilgisi
      const layerVisibility = {
        // örnek: "group_trenches": true/false,
        //        "trench_5": true/false,
        //        "group_finds": true/false,
        //        "find_10": true/false
      };

      function applyQtVisibilityToLayers() {
        const groupTrenchesVisible =
          layerVisibility["group_trenches"] !== false; // undefined -> true
        const groupFindsVisible = layerVisibility["group_finds"] !== false;

        // Açmalar (trenchLayers: id -> L.Polygon)
        Object.entries(trenchLayers).forEach(([idStr, layer]) => {
          const id = parseInt(idStr, 10);
          const key = `trench_${id}`;

          const selfVisible = layerVisibility[key] !== false; // undefined -> true
          const finalVisible = groupTrenchesVisible && selfVisible;

          if (finalVisible) {
            if (!map.hasLayer(layer)) {
              layer.addTo(map);
            }
          } else {
            if (map.hasLayer(layer)) {
              map.removeLayer(layer);
            }
          }
        });

        // Buluntular (findLayers: id -> L.CircleMarker / L.Marker)
        Object.entries(findLayers).forEach(([idStr, layer]) => {
          const id = parseInt(idStr, 10);
          const key = `find_${id}`;

          const selfVisible = layerVisibility[key] !== false;
          const finalVisible = groupFindsVisible && selfVisible;

          if (finalVisible) {
            if (!map.hasLayer(layer)) {
              layer.addTo(map);
            }
          } else {
            if (map.hasLayer(layer)) {
              map.removeLayer(layer);
            }
          }
        });
      }

      function setLayerVisibilityFromQt(layerKey, visible) {
        // Qt'den gelen anahtarı kaydet
        layerVisibility[layerKey] = visible;

        // Hangi gruba aitse ilgili katmanları güncelle
        if (layerKey === "group_trenches") {
          // tüm açmalar
          applyQtVisibilityToLayers();
        } else if (layerKey.startsWith("trench_")) {
          applyQtVisibilityToLayers();
        } else if (layerKey === "group_finds") {
          // tüm buluntular
          applyQtVisibilityToLayers();
        } else if (layerKey.startsWith("find_")) {
          applyQtVisibilityToLayers();
        } else {
          // şimdilik diğer anahtarları (levels vs.) yok say
          applyQtVisibilityToLayers();
        }
      }

      // Qt erişsin diye global'e aç
      window.setLayerVisibilityFromQt = setLayerVisibilityFromQt;
      window._applyQtVisibilityToLayers = applyQtVisibilityToLayers;

      // Offline raster’lar için tek pane
      const rasterPane = map.createPane("rasterPane");
      rasterPane.style.zIndex = 350; // OSM'in üstünde

      const osmLayer = L.tileLayer(
        "https://tile.openstreetmap.org/{z}/{x}/{y}.png",
        {
          maxZoom: 22,
          attribution: "© OpenStreetMap contributors",
        }
      ).addTo(map);

      const overlayEntries = [];
      let firstImageBounds = null;

      // URL'den zoom aralığını oku (…_z12_15/{z}/{x}/{y}.png)
      function parseZoomRangeFromUrlTemplate(urlTemplate) {
        const re = /_z(\d+)_(\d+)\/\{z\}\/\{x\}\/\{y\}\.png$/;
        const m = urlTemplate.match(re);
        if (!m) return null;
        return {
          minZoom: parseInt(m[1], 10),
          maxZoom: parseInt(m[2], 10),
        };
      }

      // Tile & image layer'ları oluştur (hepsi rasterPane'de)
      extraLayers.forEach((l) => {
        if (l.kind === "tile" && l.url_template) {
          const zoomInfo = parseZoomRangeFromUrlTemplate(l.url_template);

          const opts = {
            attribution: l.attribution || "",
            noWrap: true,
            pane: "rasterPane",
          };

          if (zoomInfo) {
            opts.maxNativeZoom = zoomInfo.maxZoom;
          }

          const layer = L.tileLayer(l.url_template, opts).addTo(map);
          overlayEntries.push({
            name: l.name,
            layer,
            kind: "tile",
          });
        } else if (l.kind === "image" && l.file_url) {
          const bounds = [
            [l.min_lat, l.min_lon],
            [l.max_lat, l.max_lon],
          ];
          const layer = L.imageOverlay(l.file_url, bounds, {
            opacity: 0.8,
            pane: "rasterPane",
          }).addTo(map);
          overlayEntries.push({
            name: l.name,
            layer,
            kind: "image",
          });
          if (!firstImageBounds) firstImageBounds = bounds;
        }
      });

      if (firstImageBounds) {
        map.fitBounds(firstImageBounds, { padding: [20, 20] });
      }

      if (errorMsg && errorMsg.trim().length > 0) {
        L.popup()
          .setLatLng([centerLat, centerLon])
          .setContent("Harita verisi yüklenirken hata: " + errorMsg)
          .openOn(map);
      }

      // Z renk skalası
      let zMin = null;
      let zMax = null;
      findsData.forEach((f) => {
        if (f.z == null) return;
        if (zMin === null || f.z < zMin) zMin = f.z;
        if (zMax === null || f.z > zMax) zMax = f.z;
      });

      function getColorForZ(z) {
        if (z == null || zMin === null || zMax === null) {
          return "#888888";
        }
        let t = (z - zMin) / (zMax - zMin || 1);
        if (t < 0) t = 0;
        if (t > 1) t = 1;

        if (t < 0.33) {
          const k = t / 0.33;
          const g = Math.round(255 * k);
          const b = 255;
          return `rgb(0,${g},${b})`;
        } else if (t < 0.66) {
          const k = (t - 0.33) / 0.33;
          const r = Math.round(255 * k);
          const g = 255;
          const b = Math.round(255 * (1 - k));
          return `rgb(${r},${g},${b})`;
        } else {
          const k = (t - 0.66) / 0.34;
          const g = Math.round(255 * (1 - k));
          return `rgb(255,${g},0)`;
        }
      }

      // Açmalar
      trenchesData.forEach((t) => {
        if (!t.vertices || !t.vertices.length) return;

        const latlngs = t.vertices.map((v) => [v.lat, v.lon]);

        const poly = L.polygon(latlngs, {
          color: "#4c9be8",
          fillColor: "#4c9be8",
          weight: 2,
          fillOpacity: 0.15,
        }).addTo(map);

        const popupText =
          "<b>Açma: </b>" +
          t.code +
          (t.name ? " – " + t.name : "") +
          "<br>" +
          "<b>Proje: </b>" +
          (t.project || "") +
          "<br>" +
          "Köşe sayısı: " +
          t.vertices.length;

        poly.bindPopup(popupText);

        trenchLayers[t.id] = poly;
      });

      // Buluntular
      findsData.forEach((f) => {
        if (f.lat == null || f.lon == null) return;

        const color = getColorForZ(f.z);

        const marker = L.circleMarker([f.lat, f.lon], {
          radius: 5,
          weight: 1,
          color: color,
          fillColor: color,
          fillOpacity: 0.9,
        }).addTo(map);

        const popupText =
          "<b>Buluntu: </b>" +
          f.code +
          "<br>" +
          "<b>Açma: </b>" +
          (f.trench_code || f.trench_id) +
          (f.trench_name ? " – " + f.trench_name : "") +
          "<br>" +
          (f.level_name ? "<b>Seviye: </b>" + f.level_name + "<br>" : "") +
          (f.description ? "Açıklama: " + f.description + "<br>" : "") +
          (f.z != null ? "Z: " + f.z + " m" : "");

        marker.bindPopup(popupText);

        findLayers[f.id] = marker;
      });

      // ---------------------------
      //  Lejant (Leaflet control)
      // ---------------------------
      const legend = L.control({ position: "bottomright" });
      legend.onAdd = function () {
        const div = L.DomUtil.create("div", "info legend");
        div.innerHTML = `
          <div class="legend-card collapsed">
            <div class="legend-header">
              <span>Lejant</span>
              <span class="toggle-icon">▸</span>
            </div>
            <div class="legend-body">
              <div class="legend-row">
                <span class="legend-swatch" style="background:#4c9be8;"></span>
                <span>Açmalar</span>
              </div>
              <div class="legend-row">
                <span class="legend-swatch round" style="background:#d62728;"></span>
                <span>Buluntular (Z'ye göre renk)</span>
              </div>
              <div class="legend-scale-title">Z Skala</div>
              <div class="legend-scale-bar"></div>
              ${
                zMin !== null && zMax !== null
                  ? `<div class="legend-z-text">Z min: ${zMin.toFixed(
                      2
                    )} m<br>Z max: ${zMax.toFixed(2)} m</div>`
                  : ""
              }
            </div>
          </div>
        `;
        setTimeout(() => {
          const card = div.querySelector(".legend-card");
          const header = div.querySelector(".legend-header");
          const icon = div.querySelector(".toggle-icon");
          header.addEventListener("click", () => {
            const isCollapsed = card.classList.toggle("collapsed");
            if (icon) icon.textContent = isCollapsed ? "▸" : "▾";
          });
        }, 0);
        return div;
      };
      legend.addTo(map);

      // ---------------------------
      //  Özel Layers Panel (Drag + Opacity)
      // ---------------------------
      const layerPanel = document.getElementById("layer-panel");
      const layerPanelHeader = document.getElementById("layer-panel-header");
      const layerPanelBody = document.getElementById("layer-panel-body");
      const layerListEl = document.getElementById("layer-list");

      // panel aç/kapa
      layerPanelHeader.addEventListener("click", () => {
        const isCollapsed = layerPanel.classList.toggle("collapsed");
        const icon = layerPanelHeader.querySelector(".toggle-icon");
        if (icon) icon.textContent = isCollapsed ? "▸" : "▾";
      });

      let dragSrcEl = null;

      function buildLayerPanel() {
        layerListEl.innerHTML = "";

        overlayEntries.forEach((entry) => {
          const item = document.createElement("div");
          item.className = "layer-item";
          item.dataset.layerName = entry.name;

          const checkbox = document.createElement("input");
          checkbox.type = "checkbox";
          checkbox.className = "layer-checkbox";
          checkbox.checked = true;

          const label = document.createElement("div");
          label.className = "layer-label";
          label.textContent = entry.name;

          const sliderWrap = document.createElement("div");
          sliderWrap.className = "layer-slider";
          const slider = document.createElement("input");
          slider.type = "range";
          slider.min = "0";
          slider.max = "100";
          slider.value = "100";
          slider.title = "Opacity";
          sliderWrap.appendChild(slider);

          const handle = document.createElement("div");
          handle.className = "layer-handle";
          handle.textContent = "⋮⋮";
          handle.draggable = true;

          item.appendChild(checkbox);
          item.appendChild(label);
          item.appendChild(sliderWrap);
          item.appendChild(handle);

          // görünürlük
          checkbox.addEventListener("change", () => {
            if (checkbox.checked) {
              entry.layer.addTo(map);
              updateLayerOrderFromDom();
            } else {
              map.removeLayer(entry.layer);
            }
          });

          // opacity
          slider.addEventListener("input", () => {
            const val = parseInt(slider.value, 10) / 100;
            if (entry.layer.setOpacity) {
              entry.layer.setOpacity(val);
            } else if (entry.layer._image) {
              entry.layer._image.style.opacity = val;
            }
          });

          ["mousedown", "touchstart", "click"].forEach((evt) => {
            slider.addEventListener(
              evt,
              (e) => {
                e.stopPropagation();
              },
              { passive: true }
            );
          });

          label.addEventListener("click", () => {
            checkbox.checked = !checkbox.checked;
            checkbox.dispatchEvent(new Event("change"));
          });

          // DRAG & DROP – sadece handle'dan
          handle.addEventListener("dragstart", (e) => {
            dragSrcEl = item;
            item.classList.add("dragging");
            e.dataTransfer.effectAllowed = "move";
          });

          handle.addEventListener("dragend", () => {
            if (dragSrcEl) {
              dragSrcEl.classList.remove("dragging");
            }
            dragSrcEl = null;
            updateLayerOrderFromDom();
          });

          item.addEventListener("dragover", (e) => {
            e.preventDefault();
            if (!dragSrcEl || dragSrcEl === item) return;
            const rect = item.getBoundingClientRect();
            const midY = rect.top + rect.height / 2;
            const parent = item.parentNode;
            if (e.clientY < midY) {
              parent.insertBefore(dragSrcEl, item);
            } else {
              parent.insertBefore(dragSrcEl, item.nextSibling);
            }
          });

          item.addEventListener("drop", (e) => {
            e.preventDefault();
            updateLayerOrderFromDom();
          });

          layerListEl.appendChild(item);
        });
      }

      function updateLayerOrderFromDom() {
        const items = Array.from(layerListEl.querySelectorAll(".layer-item"));
        const total = items.length;

        // En ÜSTTE görünen item en YÜKSEK zIndex'e sahip olsun
        items.forEach((item, index) => {
          const name = item.dataset.layerName;
          const entry = overlayEntries.find((e) => e.name === name);
          if (!entry || !map.hasLayer(entry.layer)) return;

          const z = 100 + (total - 1 - index); // index 0 → en büyük zIndex
          if (typeof entry.layer.setZIndex === "function") {
            entry.layer.setZIndex(z);
          } else if (entry.layer._image) {
            entry.layer._image.style.zIndex = z;
          }
        });
      }

      buildLayerPanel();
      updateLayerOrderFromDom();

      // ---------------------------
      //  Filtreleme
      // ---------------------------
      function applyFilter(rawQuery) {
        const q = (rawQuery || "").trim().toLowerCase();

        Object.values(trenchLayers).forEach((l) => map.removeLayer(l));
        Object.values(findLayers).forEach((l) => map.removeLayer(l));

        if (!q) {
          Object.values(trenchLayers).forEach((l) => l.addTo(map));
          Object.values(findLayers).forEach((l) => l.addTo(map));
          return;
        }

        if (q.includes("buluntu")) {
          Object.values(findLayers).forEach((l) => l.addTo(map));
          return;
        }

        if (q.includes("açma")) {
          Object.values(trenchLayers).forEach((l) => l.addTo(map));
          return;
        }

        const tokens = q.split(/\s+/).filter(Boolean);

        const visibleFindIds = [];
        const visibleTrenchIds = new Set();

        findsData.forEach((f) => {
          let text = "";
          if (f.code) text += " " + f.code;
          if (f.description) text += " " + f.description;
          if (f.trench_code) text += " " + f.trench_code;
          if (f.trench_name) text += " " + f.trench_name;
          if (f.level_name) text += " " + f.level_name;

          const t = text.toLowerCase();
          const allMatch = tokens.every((tok) => t.includes(tok));
          if (allMatch) {
            visibleFindIds.push(f.id);
            visibleTrenchIds.add(f.trench_id);
          }
        });

        trenchesData.forEach((t) => {
          let text = "";
          if (t.code) text += " " + t.code;
          if (t.name) text += " " + t.name;
          if (t.project) text += " " + t.project;

          const tt = text.toLowerCase();
          const allMatch = tokens.every((tok) => tt.includes(tok));
          if (allMatch) {
            visibleTrenchIds.add(t.id);
          }
        });

        if (!visibleFindIds.length && !visibleTrenchIds.size) {
          Object.values(findLayers).forEach((l) => l.addTo(map));
          return;
        }

        visibleFindIds.forEach((id) => {
          const layer = findLayers[id];
          if (layer) layer.addTo(map);
        });

        visibleTrenchIds.forEach((tid) => {
          const layer = trenchLayers[tid];
          if (layer) layer.addTo(map);
        });
      }
      if (window._applyQtVisibilityToLayers) {
        window._applyQtVisibilityToLayers();
      }

      const filterInput = document.getElementById("filter-input");
      if (filterInput) {
        filterInput.addEventListener("keyup", (e) => {
          if (e.key === "Enter") {
            applyFilter(filterInput.value);
          }
        });
        filterInput.addEventListener("change", () => {
          applyFilter(filterInput.value);
        });
      }

      // Odak fonksiyonları (Qt'den)
      function focusOnTrench(trenchId) {
        const layer = trenchLayers[trenchId];
        if (layer) {
          map.fitBounds(layer.getBounds(), { padding: [30, 30] });
          layer.openPopup();
        }
      }

      function focusOnFind(findId) {
        const layer = findLayers[findId];
        if (layer) {
          map.setView(layer.getLatLng(), 19);
          layer.openPopup();
        }
      }

      function focusOnAllTrenches() {
        const ids = Object.keys(trenchLayers);
        if (!ids.length) return;
        let bounds = null;
        ids.forEach((id) => {
          const b = trenchLayers[id].getBounds();
          bounds = bounds ? bounds.extend(b) : b;
        });
        if (bounds) {
          map.fitBounds(bounds, { padding: [30, 30] });
        }
      }

      function focusOnAllFinds() {
        const ids = Object.keys(findLayers);
        if (!ids.length) return;
        const latlngs = ids.map((id) => findLayers[id].getLatLng());
        let bounds = null;
        latlngs.forEach((ll) => {
          bounds = bounds ? bounds.extend(ll) : L.latLngBounds(ll, ll);
        });
        if (bounds) {
          map.fitBounds(bounds, { padding: [30, 30] });
        }
      }

      window.focusOnTrench = focusOnTrench;
      window.focusOnFind = focusOnFind;
      window.focusOnAllTrenches = focusOnAllTrenches;
      window.focusOnAllFinds = focusOnAllFinds;
      window.applyFilter = applyFilter;
    </script>
  </body>
</html>
