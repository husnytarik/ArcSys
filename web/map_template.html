<!DOCTYPE html>
<html lang="tr">
  <head>
    <meta charset="utf-8" />
    <title>ArcSys Harita</title>

    <link rel="stylesheet" href="leaflet/leaflet.css" />
    <script src="leaflet/leaflet.js"></script>
    <link rel="stylesheet" href="map_style.css" />
    <script>
      // Python bu değişkeni dolduruyor:
      const THEME_CSS_VARS = `__THEME_CSS_VARS__`;

      // CSS değişkenlerini DOM'a bas
      const root = document.documentElement;

      THEME_CSS_VARS.split("\n").forEach((line) => {
        const trimmed = line.trim();
        if (!trimmed) return;
        const [key, value] = trimmed.replace(";", "").split(":");
        if (key && value) {
          root.style.setProperty(key.trim(), value.trim());
        }
      });
    </script>

    <style>
      /* --- Filtre paneli ve slider için ek/minimal stiller --- */

      #filter-container {
        position: absolute;
        top: 10px;
        left: 60px;
        z-index: 1000;
        display: flex;
        flex-direction: column;
        gap: 6px;
        padding: 6px 8px;
        border-radius: var(--panel-radius);
        background: var(--panel-bg);
        box-shadow: 0 8px 22px rgba(0, 0, 0, 0.45);
        backdrop-filter: blur(14px);
        -webkit-backdrop-filter: blur(14px);
        border: 1px solid var(--panel-border);
      }

      #filter-input {
        padding: 4px 9px;
        font-size: 11px;
        border-radius: var(--panel-radius);
        border: 1px solid var(--filter-border);
        background: var(--filter-bg);
        color: var(--color-text);
        min-width: 230px;
        outline: none;
      }

      #filter-input::placeholder {
        color: var(--filter-placeholder);
      }

      #filter-input:focus {
        border-color: rgba(255, 255, 255, 0.32);
        box-shadow: 0 10px 26px rgba(0, 0, 0, 0.6);
      }

      .date-filter-group {
        display: flex;
        align-items: center;
        gap: 4px;
      }

      #date-from,
      #date-to {
        padding: 3px 6px;
        font-size: 11px;
        border-radius: var(--panel-radius);
        border: 1px solid var(--filter-border);
        background: var(--filter-bg);
        color: var(--color-text);
        outline: none;
        min-width: 110px;
      }

      #date-from::placeholder,
      #date-to::placeholder {
        color: var(--filter-placeholder);
      }

      #date-from:focus,
      #date-to:focus {
        border-color: rgba(255, 255, 255, 0.32);
      }

      .filter-separator {
        font-size: 11px;
        color: var(--filter-placeholder);
      }

      #date-filter-clear {
        border: none;
        background: var(--panel-bg);
        color: var(--color-text-muted);
        border-radius: 999px;
        width: 18px;
        height: 18px;
        cursor: pointer;
        font-size: 11px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      #date-filter-clear:hover {
        background: var(--panel-border);
      }

      /* === Seviye slider kısmı === */

      #depth-filter-group {
        display: flex;
        flex-direction: column;
        gap: 3px;
        margin-top: 2px;
      }

      #depth-label-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 11px;
        color: var(--color-text-muted);
      }

      .depth-title {
        font-weight: 500;
      }

      #depth-range-label {
        font-size: 11px;
      }

      #depth-slider-row {
        position: relative;
        height: 16px;
        display: flex;
        align-items: center;
        border-radius: 999px;
        padding: 4px 0;
        /* Arka plan: dış bar (seçilmemiş alan) */
        background: linear-gradient(
          to right,
          rgba(255, 255, 255, 0.14),
          rgba(255, 255, 255, 0.14)
        );
      }

      /* İki range’i üst üste bindiriyoruz */
      #depth-min,
      #depth-max {
        -webkit-appearance: none;
        appearance: none;
        width: 100%;
        position: absolute;
        pointer-events: none; /* thumb hariç */
        background: transparent; /* aradaki rengi JS ile parent'a veriyoruz */
      }

      /* Track */
      #depth-min::-webkit-slider-runnable-track,
      #depth-max::-webkit-slider-runnable-track {
        height: 4px;
        border-radius: 999px;
        background: transparent; /* arka planı parent'tan al */
      }
      #depth-min::-moz-range-track,
      #depth-max::-moz-range-track {
        height: 4px;
        border-radius: 999px;
        background: transparent;
      }

      /* Thumb */
      #depth-min::-webkit-slider-thumb,
      #depth-max::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        height: 11px;
        width: 11px;
        border-radius: 999px;
        background: #ffffff;
        border: 1px solid rgba(0, 0, 0, 0.55);
        cursor: pointer;
        pointer-events: all;
        margin-top: -4px;
      }
      #depth-min::-moz-range-thumb,
      #depth-max::-moz-range-thumb {
        height: 11px;
        width: 11px;
        border-radius: 999px;
        background: #ffffff;
        border: 1px solid rgba(0, 0, 0, 0.55);
        cursor: pointer;
        pointer-events: all;
      }
    </style>
  </head>

  <body>
    <div id="map"></div>

    <!-- Filtre -->
    <div id="filter-container">
      <!-- Metin filtresi -->
      <input
        id="filter-input"
        placeholder="Metin filtresi: buluntu / açma / seviye"
      />

      <!-- Tarih aralığı -->
      <div class="date-filter-group">
        <input
          id="date-from"
          type="text"
          inputmode="numeric"
          placeholder="gg.aa.yyyy"
          title="Başlangıç tarihi (gg.aa.yyyy)"
        />
        <span class="filter-separator">–</span>
        <input
          id="date-to"
          type="text"
          inputmode="numeric"
          placeholder="gg.aa.yyyy"
          title="Bitiş tarihi (gg.aa.yyyy)"
        />
        <button id="date-filter-clear" title="Tarih filtresini temizle">
          ×
        </button>
      </div>

      <!-- Seviye (Z) aralığı slider -->
      <div id="depth-filter-group">
        <div id="depth-label-row">
          <span class="depth-title">Seviye (Z):</span>
          <span id="depth-range-label"></span>
        </div>
        <div id="depth-slider-row">
          <input type="range" id="depth-min" step="0.01" />
          <input type="range" id="depth-max" step="0.01" />
        </div>
      </div>
    </div>

    <!-- Özel Layers Panel -->
    <div id="layer-panel" class="collapsed">
      <div id="layer-panel-header">
        <span class="title">Katmanlar</span>
        <span class="toggle-icon">▸</span>
      </div>
      <div id="layer-panel-body">
        <div id="layer-list"></div>
      </div>
    </div>

    <script>
      const trenchesData = __TRENCHES_JSON__;
      const findsData = __FINDS_JSON__;
      const extraLayers = __LAYERS_JSON__;
      const errorMsg = "__ERROR_MSG__";
      const centerLat = __CENTER_LAT__;
      const centerLon = __CENTER_LON__;

      const trenchLayers = {};
      const findLayers = {};

      // Map
      const map = L.map("map").setView([centerLat, centerLon], 17);

      // Qt'den gelen layer visibility bilgisi
      const layerVisibility = {};

      function applyQtVisibilityToLayers() {
        const groupTrenchesVisible =
          layerVisibility["group_trenches"] !== false;
        const groupFindsVisible = layerVisibility["group_finds"] !== false;

        Object.entries(trenchLayers).forEach(([idStr, layer]) => {
          const id = parseInt(idStr, 10);
          const key = `trench_${id}`;
          const selfVisible = layerVisibility[key] !== false;
          const finalVisible = groupTrenchesVisible && selfVisible;

          if (finalVisible) {
            if (!map.hasLayer(layer)) layer.addTo(map);
          } else {
            if (map.hasLayer(layer)) map.removeLayer(layer);
          }
        });

        Object.entries(findLayers).forEach(([idStr, layer]) => {
          const id = parseInt(idStr, 10);
          const key = `find_${id}`;
          const selfVisible = layerVisibility[key] !== false;
          const finalVisible = groupFindsVisible && selfVisible;

          if (finalVisible) {
            if (!map.hasLayer(layer)) layer.addTo(map);
          } else {
            if (map.hasLayer(layer)) map.removeLayer(layer);
          }
        });
      }

      function setLayerVisibilityFromQt(layerKey, visible) {
        layerVisibility[layerKey] = visible;
        applyQtVisibilityToLayers();
      }

      window.setLayerVisibilityFromQt = setLayerVisibilityFromQt;
      window._applyQtVisibilityToLayers = applyQtVisibilityToLayers;

      // Offline raster’lar için tek pane
      const rasterPane = map.createPane("rasterPane");
      rasterPane.style.zIndex = 350;

      const osmLayer = L.tileLayer(
        "https://tile.openstreetmap.org/{z}/{x}/{y}.png",
        {
          maxZoom: 22,
          attribution: "© OpenStreetMap contributors",
        }
      ).addTo(map);

      const overlayEntries = [];
      let firstImageBounds = null;

      function parseZoomRangeFromUrlTemplate(urlTemplate) {
        const re = /_z(\d+)_(\d+)\/\{z\}\/\{x\}\/\{y\}\.png$/;
        const m = urlTemplate.match(re);
        if (!m) return null;
        return {
          minZoom: parseInt(m[1], 10),
          maxZoom: parseInt(m[2], 10),
        };
      }

      extraLayers.forEach((l) => {
        if (l.kind === "tile" && l.url_template) {
          const zoomInfo = parseZoomRangeFromUrlTemplate(l.url_template);
          const opts = {
            attribution: l.attribution || "",
            noWrap: true,
            pane: "rasterPane",
          };
          if (zoomInfo) {
            opts.maxNativeZoom = zoomInfo.maxZoom;
          }
          const layer = L.tileLayer(l.url_template, opts).addTo(map);
          overlayEntries.push({ name: l.name, layer, kind: "tile" });
        } else if (l.kind === "image" && l.file_url) {
          const bounds = [
            [l.min_lat, l.min_lon],
            [l.max_lat, l.max_lon],
          ];
          const layer = L.imageOverlay(l.file_url, bounds, {
            opacity: 0.8,
            pane: "rasterPane",
          }).addTo(map);
          overlayEntries.push({ name: l.name, layer, kind: "image" });
          if (!firstImageBounds) firstImageBounds = bounds;
        }
      });

      if (firstImageBounds) {
        map.fitBounds(firstImageBounds, { padding: [20, 20] });
      }

      if (errorMsg && errorMsg.trim().length > 0) {
        L.popup()
          .setLatLng([centerLat, centerLon])
          .setContent("Harita verisi yüklenirken hata: " + errorMsg)
          .openOn(map);
      }

      // Z renk skalası
      let zMin = null;
      let zMax = null;
      findsData.forEach((f) => {
        if (f.z == null) return;
        if (zMin === null || f.z < zMin) zMin = f.z;
        if (zMax === null || f.z > zMax) zMax = f.z;
      });

      function getColorForZ(z) {
        if (z == null || zMin === null || zMax === null) {
          return "#888888";
        }
        let t = (z - zMin) / (zMax - zMin || 1);
        if (t < 0) t = 0;
        if (t > 1) t = 1;

        if (t < 0.33) {
          const k = t / 0.33;
          const g = Math.round(255 * k);
          const b = 255;
          return `rgb(0,${g},${b})`;
        } else if (t < 0.66) {
          const k = (t - 0.33) / 0.33;
          const r = Math.round(255 * k);
          const g = 255;
          const b = Math.round(255 * (1 - k));
          return `rgb(${r},${g},${b})`;
        } else {
          const k = (t - 0.66) / 0.34;
          const g = Math.round(255 * (1 - k));
          return `rgb(255,${g},0)`;
        }
      }

      // Açmalar
      trenchesData.forEach((t) => {
        if (!t.vertices || !t.vertices.length) return;

        const latlngs = t.vertices.map((v) => [v.lat, v.lon]);

        const poly = L.polygon(latlngs, {
          color: "#4c9be8",
          fillColor: "#4c9be8",
          weight: 2,
          fillOpacity: 0.15,
        }).addTo(map);

        const popupText =
          "<b>Açma: </b>" +
          t.code +
          (t.name ? " – " + t.name : "") +
          "<br>" +
          "<b>Proje: </b>" +
          (t.project || "") +
          "<br>" +
          "Köşe sayısı: " +
          t.vertices.length;

        poly.bindPopup(popupText);
        trenchLayers[t.id] = poly;
      });

      // Buluntular
      findsData.forEach((f) => {
        if (f.lat == null || f.lon == null) return;

        const color = getColorForZ(f.z);

        const marker = L.circleMarker([f.lat, f.lon], {
          radius: 5,
          weight: 1,
          color: color,
          fillColor: color,
          fillOpacity: 0.9,
        }).addTo(map);

        const popupText =
          "<b>Buluntu: </b>" +
          f.code +
          "<br>" +
          "<b>Açma: </b>" +
          (f.trench_code || f.trench_id) +
          (f.trench_name ? " – " + f.trench_name : "") +
          "<br>" +
          (f.level_name ? "<b>Seviye: </b>" + f.level_name + "<br>" : "") +
          (f.description ? "Açıklama: " + f.description + "<br>" : "") +
          (f.z != null ? "Z: " + f.z + " m" : "");

        marker.bindPopup(popupText);
        findLayers[f.id] = marker;
      });

      // ---------------------------
      //  Lejant
      // ---------------------------
      const legend = L.control({ position: "bottomright" });
      legend.onAdd = function () {
        const div = L.DomUtil.create("div", "info legend");
        div.innerHTML = `
          <div class="legend-card collapsed">
            <div class="legend-header">
              <span>Lejant</span>
              <span class="toggle-icon">▸</span>
            </div>
            <div class="legend-body">
              <div class="legend-row">
                <span class="legend-swatch" style="background:#4c9be8;"></span>
                <span>Açmalar</span>
              </div>
              <div class="legend-row">
                <span class="legend-swatch round" style="background:#d62728;"></span>
                <span>Buluntular (Z'ye göre renk)</span>
              </div>
              <div class="legend-scale-title">Z Skala</div>
              <div class="legend-scale-bar"></div>
              ${
                zMin !== null && zMax !== null
                  ? `<div class="legend-z-text">Z min: ${zMin.toFixed(
                      2
                    )} m<br>Z max: ${zMax.toFixed(2)} m</div>`
                  : ""
              }
            </div>
          </div>
        `;
        setTimeout(() => {
          const card = div.querySelector(".legend-card");
          const header = div.querySelector(".legend-header");
          const icon = div.querySelector(".toggle-icon");
          header.addEventListener("click", () => {
            const isCollapsed = card.classList.toggle("collapsed");
            if (icon) icon.textContent = isCollapsed ? "▸" : "▾";
          });
        }, 0);
        return div;
      };
      legend.addTo(map);

      // ---------------------------
      //  Layers Panel
      // ---------------------------
      const layerPanel = document.getElementById("layer-panel");
      const layerPanelHeader = document.getElementById("layer-panel-header");
      const layerPanelBody = document.getElementById("layer-panel-body");
      const layerListEl = document.getElementById("layer-list");

      layerPanelHeader.addEventListener("click", () => {
        const isCollapsed = layerPanel.classList.toggle("collapsed");
        const icon = layerPanelHeader.querySelector(".toggle-icon");
        if (icon) icon.textContent = isCollapsed ? "▸" : "▾";
      });

      let dragSrcEl = null;

      function buildLayerPanel() {
        layerListEl.innerHTML = "";

        overlayEntries.forEach((entry) => {
          const item = document.createElement("div");
          item.className = "layer-item";
          item.dataset.layerName = entry.name;

          const checkbox = document.createElement("input");
          checkbox.type = "checkbox";
          checkbox.className = "layer-checkbox";
          checkbox.checked = true;

          const label = document.createElement("div");
          label.className = "layer-label";
          label.textContent = entry.name;

          const sliderWrap = document.createElement("div");
          sliderWrap.className = "layer-slider";
          const slider = document.createElement("input");
          slider.type = "range";
          slider.min = "0";
          slider.max = "100";
          slider.value = "100";
          slider.title = "Opacity";
          sliderWrap.appendChild(slider);

          const handle = document.createElement("div");
          handle.className = "layer-handle";
          handle.textContent = "⋮⋮";
          handle.draggable = true;

          item.appendChild(checkbox);
          item.appendChild(label);
          item.appendChild(sliderWrap);
          item.appendChild(handle);

          checkbox.addEventListener("change", () => {
            if (checkbox.checked) {
              entry.layer.addTo(map);
              updateLayerOrderFromDom();
            } else {
              map.removeLayer(entry.layer);
            }
          });

          slider.addEventListener("input", () => {
            const val = parseInt(slider.value, 10) / 100;
            if (entry.layer.setOpacity) {
              entry.layer.setOpacity(val);
            } else if (entry.layer._image) {
              entry.layer._image.style.opacity = val;
            }
          });

          ["mousedown", "touchstart", "click"].forEach((evt) => {
            slider.addEventListener(
              evt,
              (e) => {
                e.stopPropagation();
              },
              { passive: true }
            );
          });

          label.addEventListener("click", () => {
            checkbox.checked = !checkbox.checked;
            checkbox.dispatchEvent(new Event("change"));
          });

          handle.addEventListener("dragstart", (e) => {
            dragSrcEl = item;
            item.classList.add("dragging");
            e.dataTransfer.effectAllowed = "move";
          });

          handle.addEventListener("dragend", () => {
            if (dragSrcEl) dragSrcEl.classList.remove("dragging");
            dragSrcEl = null;
            updateLayerOrderFromDom();
          });

          item.addEventListener("dragover", (e) => {
            e.preventDefault();
            if (!dragSrcEl || dragSrcEl === item) return;
            const rect = item.getBoundingClientRect();
            const midY = rect.top + rect.height / 2;
            const parent = item.parentNode;
            if (e.clientY < midY) {
              parent.insertBefore(dragSrcEl, item);
            } else {
              parent.insertBefore(dragSrcEl, item.nextSibling);
            }
          });

          item.addEventListener("drop", (e) => {
            e.preventDefault();
            updateLayerOrderFromDom();
          });

          layerListEl.appendChild(item);
        });
      }

      function updateLayerOrderFromDom() {
        const items = Array.from(layerListEl.querySelectorAll(".layer-item"));
        const total = items.length;

        items.forEach((item, index) => {
          const name = item.dataset.layerName;
          const entry = overlayEntries.find((e) => e.name === name);
          if (!entry || !map.hasLayer(entry.layer)) return;

          const z = 100 + (total - 1 - index);
          if (typeof entry.layer.setZIndex === "function") {
            entry.layer.setZIndex(z);
          } else if (entry.layer._image) {
            entry.layer._image.style.zIndex = z;
          }
        });
      }

      buildLayerPanel();
      updateLayerOrderFromDom();

      // ---------------------------
      //  Seviye (Z) slider ayarları
      // ---------------------------
      let DEPTH_MIN = null;
      let DEPTH_MAX = null;

      (function initDepthRangeFromFinds() {
        if (zMin === null || zMax === null) return;
        DEPTH_MIN = zMin;
        DEPTH_MAX = zMax;

        const depthMinInput = document.getElementById("depth-min");
        const depthMaxInput = document.getElementById("depth-max");
        const depthLabel = document.getElementById("depth-range-label");

        if (depthMinInput && depthMaxInput) {
          depthMinInput.min = DEPTH_MIN;
          depthMinInput.max = DEPTH_MAX;
          depthMaxInput.min = DEPTH_MIN;
          depthMaxInput.max = DEPTH_MAX;

          depthMinInput.value = DEPTH_MIN;
          depthMaxInput.value = DEPTH_MAX;

          if (depthLabel) {
            depthLabel.textContent =
              DEPTH_MIN.toFixed(2) + " – " + DEPTH_MAX.toFixed(2);
          }

          // ilk yüklemede barın rengini ayarla
          updateDepthBarBackground(DEPTH_MIN, DEPTH_MAX);
        }
      })();

      function updateDepthBarBackground(zFrom, zTo) {
        const row = document.getElementById("depth-slider-row");
        if (!row || DEPTH_MIN === null || DEPTH_MAX === null) return;

        const total = DEPTH_MAX - DEPTH_MIN || 1;
        const startPct = ((zFrom - DEPTH_MIN) / total) * 100;
        const endPct = ((zTo - DEPTH_MIN) / total) * 100;

        const styles = getComputedStyle(document.documentElement);
        const bg =
          styles.getPropertyValue("--filter-bg").trim() ||
          "rgba(255,255,255,0.06)";
        const accentSoft =
          styles.getPropertyValue("--color-accent-soft").trim() ||
          styles.getPropertyValue("--color-accent").trim() ||
          "rgba(255,255,255,0.65)";

        row.style.background = `
          linear-gradient(
            to right,
            ${bg} 0%,
            ${bg} ${startPct}%,
            ${accentSoft} ${startPct}%,
            ${accentSoft} ${endPct}%,
            ${bg} ${endPct}%,
            ${bg} 100%
          )
        `;
      }

      // ---------------------------
      //  Yardımcı fonksiyonlar (tarih + seviye)
      // ---------------------------
      // dd.mm.yyyy / dd-mm-yyyy / dd/mm/yyyy / yyyy-mm-dd / "yyyy-mm-dd hh:mm:ss"
      function parseDateLoose(str) {
        if (!str) return null;
        let s = String(str).trim();
        if (!s) return null;

        // Eğer "2025-11-29 23:58:00" gibi ise önce boşlukta kes
        const spaceIndex = s.indexOf(" ");
        if (spaceIndex !== -1) {
          s = s.slice(0, spaceIndex); // sadece tarih kısmını al
        }

        // dd.mm.yyyy / dd-mm-yyyy / dd/mm/yyyy
        let m = s.match(/^(\d{1,2})[.\-\/](\d{1,2})[.\-\/](\d{4})$/);
        if (m) {
          const d = parseInt(m[1], 10);
          const mo = parseInt(m[2], 10);
          const y = parseInt(m[3], 10);
          const dt = new Date(y, mo - 1, d);
          if (!isNaN(dt.getTime())) return dt;
        }

        // yyyy-mm-dd (DB ISO formatı)
        m = s.match(/^(\d{4})-(\d{2})-(\d{2})$/);
        if (m) {
          const y = parseInt(m[1], 10);
          const mo = parseInt(m[2], 10);
          const d = parseInt(m[3], 10);
          const dt = new Date(y, mo - 1, d);
          if (!isNaN(dt.getTime())) return dt;
        }

        return null;
      }

      function getDateRangeFromInputs() {
        const fromEl = document.getElementById("date-from");
        const toEl = document.getElementById("date-to");

        let from = null;
        let to = null;

        if (fromEl && fromEl.value) {
          from = parseDateLoose(fromEl.value);
          if (from) from.setHours(0, 0, 0, 0);
        }
        if (toEl && toEl.value) {
          to = parseDateLoose(toEl.value);
          if (to) to.setHours(23, 59, 59, 999);
        }

        return { from, to };
      }

      function getDepthRangeFromSliders() {
        const depthMinInput = document.getElementById("depth-min");
        const depthMaxInput = document.getElementById("depth-max");
        const depthLabel = document.getElementById("depth-range-label");

        if (!depthMinInput || !depthMaxInput) {
          return { zFrom: null, zTo: null };
        }

        let zFrom = parseFloat(depthMinInput.value);
        let zTo = parseFloat(depthMaxInput.value);

        if (isNaN(zFrom) || DEPTH_MIN === null) zFrom = DEPTH_MIN;
        if (isNaN(zTo) || DEPTH_MAX === null) zTo = DEPTH_MAX;

        if (zFrom > zTo) {
          const tmp = zFrom;
          zFrom = zTo;
          zTo = tmp;
        }

        if (depthLabel && zFrom != null && zTo != null) {
          depthLabel.textContent = zFrom.toFixed(2) + " – " + zTo.toFixed(2);
        }

        updateDepthBarBackground(zFrom, zTo);
        return { zFrom, zTo };
      }

      function findMatchesDateRange(find, from, to) {
        const raw =
          find.date_iso ||
          find.date ||
          find.find_date ||
          find.found_at || // <<< BURADA found_at'i de kullanıyoruz
          null;

        // Hiç tarih filtresi yoksa → tarihle uğraşma
        if (!from && !to) return true;

        // Bu buluntunun tarihsiz olması durumunda:
        // → ELEME, görünmeye devam etsin
        if (!raw) return true;

        const d = parseDateLoose(raw);
        if (!d) return true; // okunamıyorsa da eleme

        if (from && d < from) return false;
        if (to && d > to) return false;

        return true;
      }

      function findMatchesDepthRange(find, zFrom, zTo) {
        if (zFrom == null || zTo == null) return true;
        const z = typeof find.z === "number" ? find.z : parseFloat(find.z);
        if (isNaN(z)) return false;

        if (z < zFrom) return false;
        if (z > zTo) return false;
        return true;
      }

      // ---------------------------
      //  Filtreleme (metin + tarih + seviye)
      // ---------------------------
      function applyFilter(rawQuery) {
        const q = (rawQuery || "").trim().toLowerCase();
        const { from, to } = getDateRangeFromInputs();
        const { zFrom, zTo } = getDepthRangeFromSliders();

        const hasDateFilter = !!(from || to);
        const hasDepthFilter = zFrom != null && zTo != null;

        Object.values(trenchLayers).forEach((l) => map.removeLayer(l));
        Object.values(findLayers).forEach((l) => map.removeLayer(l));

        if (!q && !hasDateFilter && !hasDepthFilter) {
          Object.values(trenchLayers).forEach((l) => l.addTo(map));
          Object.values(findLayers).forEach((l) => l.addTo(map));
          return;
        }

        const tokens = q.split(/\s+/).filter(Boolean);

        const visibleFindIds = [];
        const visibleTrenchIds = new Set();

        findsData.forEach((f) => {
          if (!findMatchesDateRange(f, from, to)) return;
          if (!findMatchesDepthRange(f, zFrom, zTo)) return;

          let text = "";
          if (f.code) text += " " + f.code;
          if (f.description) text += " " + f.description;
          if (f.trench_code) text += " " + f.trench_code;
          if (f.trench_name) text += " " + f.trench_name;
          if (f.level_name) text += " " + f.level_name;

          const t = text.toLowerCase();
          const textOk =
            !tokens.length || tokens.every((tok) => t.includes(tok));

          if (textOk) {
            visibleFindIds.push(f.id);
            if (f.trench_id != null) visibleTrenchIds.add(f.trench_id);
          }
        });

        trenchesData.forEach((tData) => {
          let text = "";
          if (tData.code) text += " " + tData.code;
          if (tData.name) text += " " + tData.name;
          if (tData.project) text += " " + tData.project;

          const tt = text.toLowerCase();
          const textOk =
            !tokens.length || tokens.every((tok) => tt.includes(tok));

          if (textOk) {
            visibleTrenchIds.add(tData.id);
          }
        });

        if (!visibleFindIds.length && !visibleTrenchIds.size) {
          if (!hasDateFilter && !hasDepthFilter) {
            Object.values(findLayers).forEach((l) => l.addTo(map));
            Object.values(trenchLayers).forEach((l) => l.addTo(map));
          }
          return;
        }

        visibleFindIds.forEach((id) => {
          const layer = findLayers[id];
          if (layer) layer.addTo(map);
        });

        visibleTrenchIds.forEach((tid) => {
          const layer = trenchLayers[tid];
          if (layer) layer.addTo(map);
        });
      }

      // ---------------------------
      //  Event listener’lar
      // ---------------------------
      const filterInput = document.getElementById("filter-input");
      if (filterInput) {
        filterInput.addEventListener("keyup", (e) => {
          if (e.key === "Enter") {
            applyFilter(filterInput.value);
          }
        });
        filterInput.addEventListener("change", () => {
          applyFilter(filterInput.value);
        });
      }

      const dateFromInput = document.getElementById("date-from");
      const dateToInput = document.getElementById("date-to");
      const clearDateBtn = document.getElementById("date-filter-clear");

      if (dateFromInput) {
        dateFromInput.addEventListener("change", () => {
          applyFilter(filterInput ? filterInput.value : "");
        });
      }

      if (dateToInput) {
        dateToInput.addEventListener("focus", () => {
          if (dateToInput.showPicker) dateToInput.showPicker();
        });
        dateToInput.addEventListener("change", () => {
          applyFilter(filterInput ? filterInput.value : "");
        });
      }

      if (clearDateBtn) {
        clearDateBtn.addEventListener("click", () => {
          if (dateFromInput) dateFromInput.value = "";
          if (dateToInput) dateToInput.value = "";
          applyFilter(filterInput ? filterInput.value : "");
        });
      }

      const depthMinInput = document.getElementById("depth-min");
      const depthMaxInput = document.getElementById("depth-max");

      if (depthMinInput) {
        depthMinInput.addEventListener("input", () => {
          applyFilter(filterInput ? filterInput.value : "");
        });
      }
      if (depthMaxInput) {
        depthMaxInput.addEventListener("input", () => {
          applyFilter(filterInput ? filterInput.value : "");
        });
      }

      // Odak fonksiyonları
      function focusOnTrench(trenchId) {
        const layer = trenchLayers[trenchId];
        if (layer) {
          map.fitBounds(layer.getBounds(), { padding: [30, 30] });
          layer.openPopup();
        }
      }

      function focusOnFind(findId) {
        const layer = findLayers[findId];
        if (layer) {
          map.setView(layer.getLatLng(), 19);
          layer.openPopup();
        }
      }

      function focusOnAllTrenches() {
        const ids = Object.keys(trenchLayers);
        if (!ids.length) return;
        let bounds = null;
        ids.forEach((id) => {
          const b = trenchLayers[id].getBounds();
          bounds = bounds ? bounds.extend(b) : b;
        });
        if (bounds) {
          map.fitBounds(bounds, { padding: [30, 30] });
        }
      }

      function focusOnAllFinds() {
        const ids = Object.keys(findLayers);
        if (!ids.length) return;
        const latlngs = ids.map((id) => findLayers[id].getLatLng());
        let bounds = null;
        latlngs.forEach((ll) => {
          bounds = bounds ? bounds.extend(ll) : L.latLngBounds(ll, ll);
        });
        if (bounds) {
          map.fitBounds(bounds, { padding: [30, 30] });
        }
      }

      window.focusOnTrench = focusOnTrench;
      window.focusOnFind = focusOnFind;
      window.focusOnAllTrenches = focusOnAllTrenches;
      window.focusOnAllFinds = focusOnAllFinds;
      window.applyFilter = applyFilter;
    </script>
  </body>
</html>
